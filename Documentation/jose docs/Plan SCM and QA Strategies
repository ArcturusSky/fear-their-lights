SCM & QA Strategy
Source Code Management (SCM) Strategy
Version Control System:
We will use Git with a GitHub repository to track changes, collaborate, and maintain code integrity.
Branching Strategy:
We follow a structured Git Flow model to maintain stability while enabling feature development:
    1. main branch → Production-ready code.
    2. develop branch → Active development; tested before merging into main.
    3. Feature branches (feature/*) → New features are developed here. Example: feature/user-authentication.
    4. Bugfix branches (bugfix/*) → Quick fixes for issues found in staging or production. Example: bugfix/login-error.
    5. Hotfix branches (hotfix/*) → Urgent fixes for production. Example: hotfix/server-crash.
Commit & Merge Strategy:
    • Frequent commits (small, atomic changes).
    • Descriptive commit messages (feat: add user authentication instead of fixed something).
    • Pull requests (PRs) required before merging to develop or main.
    • Code review process:
        ◦ At least one approval from a senior developer before merging.
        ◦ Ensure code adheres to style guides and has necessary test coverage.
    • Merge Strategy:
        ◦ Feature branches → Merged into develop after approval.
        ◦ Develop branch → Merged into main after passing QA.

Quality Assurance (QA) Strategy
Testing Methodology:
We will implement a Test-Driven Development (TDD) approach to ensure code quality and reliability.
Test Type
Purpose
Tools Used
Scope
Unit Tests
Verify individual components/functions
Jest (for frontend & backend)
API endpoints, UI components, utility functions
Integration Tests
Ensure APIs work together correctly
Postman, Supertest
Backend services interacting with Supabase
End-to-End (E2E) Tests
Validate user workflows
Cypress
User authentication, gameplay interactions
Performance Testing
Test system under load
JMeter, k6
API response times, WebSocket efficiency
Manual Testing
Exploratory testing for edge cases
QA testers
UI, UX, and gameplay mechanics
CI/CD & Deployment Pipeline:
    1. GitHub Actions for CI/CD
        ◦ Runs unit & integration tests automatically on push.
        ◦ Deploys to staging on merging to develop.
        ◦ Deploys to production on merging to main.
    2. Environments
        ◦ Local Development → Developers test on local machines using .env.local.
        ◦ Staging (Test Server) → Pre-production environment for QA testing.
        ◦ Production → Live environment used by players.

Summary
    • SCM Strategy:
        ◦ Git + GitHub
        ◦ Feature-based branching
        ◦ Pull requests with code reviews
    • QA Strategy:
        ◦ Automated tests: Jest, Postman, Cypress
        ◦ Manual testing for UX & gameplay
        ◦ Continuous Integration with GitHub Actions
